type error = {
    code: int;
    message: string;
}

type failure = {
    id: int;
    error: error;
}

type response = {
    ~jsonrpc <python default="'2.0'">: string;
    id: int;
    result: abstract;
}

type request = {
    ~jsonrpc <python default="'2.0'">: string;
    id: int;
    method_ <json name="method">: string;
    params: abstract
}

type opts = {
    ~memo <python default="True">: bool;
    ~hash <python default="True">: bool;
}

type position = {
    line: int;
    character: int;
}

type state = {
    st: int;
    ?hash: int option;
    proof_finished: bool;
    feedback: (int * string) list;
    ~generation <python default="0">: int;
}

type goal_hyp = {
    names: string list;
    ?def_ <json name="def">: abstract option;
    ty: string;
}

type goal = {
    info: abstract;
    hyps: goal_hyp list;
    ty: string;
    ?pp: string option;
}

type range = {
    start: position;
    end: position;
}

type name = {
    v: string nullable;
    range: range;
}

type toc_element = {
    children: toc_element list nullable;
    detail: string;
    kind: int;
    name: name;
    range: range;
}

type inspect = [
    InspectPhysical <json name="Physical"> |
    InspectGoals <json name="Goals">
]

type notation_info = {
    locations: abstract list;
    path: string;
    secpath: string;
    notation: string;
    scope: string nullable;
}

type start_params = {
    ?pre_commands: string option;
    ?opts: opts option;
    uri: string;
    thm: string;
}

type start_response = state

type set_workspace_params = {
    debug: bool;
    root: string;
}

type set_workspace_response = abstract

type run_params = {
    ?opts: opts option;
    st: state;
    tac: string;
}

type run_response = state

type goals_params = {
    st: state;
}

type goals_response = {
    goals : goal list;
    stack: (abstract list * abstract list) list;
    shelf: abstract list;
    given_up: abstract list
}

type premises_params = {
    st: state;
}

type premises_response = abstract

type state_equal_params = {
    kind: inspect list;
    st1: state;
    st2: state;
}

type state_equal_response = bool

type state_hash_params = {
    st: state;
}

type state_hash_response = int

type toc_params = {
    uri: string;
}

type toc_response = (string * toc_element list) list

type ast_params = {
    st: state;
    text: string;
}

type ast_response = abstract

type ast_at_pos_params = {
    uri: string;
    position: position;
}

type ast_at_pos_response = abstract

type get_state_at_pos_params = {
    ?opts: opts option;
    uri: string;
    position: position
}

type get_state_at_pos_response = state

type get_root_state_params = {
    ?opts: opts option;
    uri: string;
}

type get_root_state_response = state

type list_notations_in_statement_params = {
    st: state;
    statement: string;
}

type list_notations_in_statement_response = {
    st: notation_info list
}
